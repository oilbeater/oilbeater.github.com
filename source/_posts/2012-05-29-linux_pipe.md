---
layout: post
title: "linux管道机制简介"
description: "管道是linux提供的一种常见的进程通信工具，也是很多shell命令能够灵活组合产生强大用途的一个重要工具。本文就八卦一下它是怎么实现的。"
category: "Linux" 
tagline: "Hack the life!"
tags: [技术, 源码阅读]
img: "http://lh6.googleusercontent.com/-vRXcYw7V7fg/T69fVsIkNaI/AAAAAAAAAIw/Y3KgmC33VbI/s512/linux.jpg"
---
<div>
	<p>管道是linux提供的一种常见的进程通信工具，也是很多shell命令能够灵活组合产生强大用途的一个重要工具。本文就八卦一下它是怎么实现的。</p>
	<p>唉，看完这片，我打算还是从进程管理，内存管理和文件管理这三大块开始看了，一开始以为这些边边角角的东西会容易懂一些，结果老是用到这三大块的东西，总要回去查。</p>
<h2>管道是什么？</h2>
	<p>管道，顾名思义就是个管子，里面可以流过去很多东西。举个栗子<code> ls | more</code>ls输出列出来的文件目录就通过‘|’这个管道流向了more这个文本浏览器。相同的功能我们也可以通过<code>ls > tmp ; tmp > more</code>来完成。实际上管道的功能和第二个方法也很像。管道也是一个文件ls的输出送到这个文件，more再从这个文件将东西拿走。所不同的是管道不同于普通的文件，是一套特殊的文件pipefs，在磁盘中没有映像，只在内存中存在，而且只存在于存在亲缘关系的进程之间。然后省略若干和文件系统，linux进程相关的知识…………好吧我还是说两句吧。</p>
<h2>为什么是特殊的文件？</h2>
	<p>我们知道有句传说是linux系统中一切皆文件，事实上这句话很忽悠人，虽然都是文件一个文本文件能和一个CPU设备一样么。实际上常用的特殊文件类型就有十多种，之所以要把他们都组织成文件是为了应用级别的程序员编程方便，不管操纵什么东西，文件、设备、socket等等都可以open之后read，write再close，可事实上调用的底层的系统程序是不一样的。这个想想也知道，写一个文本用的实际操作和往一个socket写东西怎么可能一样。pipe特殊就在于它是进程通信的一种方法，这种发法要保证一定的速度，所以就不好扔到硬盘上去读写了，干脆就直接在内存上读写了，所以它成为一个文件只是为了接口的方便。</p>
	<p>至于说它只在有亲缘关系的进程间共享，是因为管道属于进程打开的文件，只有创建管道的进程fork出来的子进程可以共享这个管道的文件描述符，其他无关系的进程是看不到这个管道的，所以说是一种非常狭隘小资的通信方式。</p>
<h2>管道的创建</h2>
<img src="http://lh4.googleusercontent.com/-rKXoItZdeME/T8TMQ1hwu-I/AAAAAAAAARM/ERbFu9BqHb0/s470/pipe.gif" alt="" style="float:none;">
	<p>管道有两个口，一个入水口一个出水口。pipe系统调用会返回两个文件描述符，一个文件描述符用来写一个用来读。如上图所示，两个file结构指向同一个inode，对应管道在内存种所获得的一片区域。这里稍微要注意的一点是，尽管我们平时的应用都是一个管道对应一个写进程一个读进程，但是管道本身是支持多个进程进行读写的，他们只要对相同的描述符进行操作，加之系统的互斥进程就可以实现多进程的通信。这里也可以看出管道是半双工的，没有一个文件描述符可以用来进行读and写，如果想在两进程间进行全双工操作就开两条管道吧。</p>
<h2>管道读写</h2>
	<p>前面说过了，不同的文件类型的write和read操作是不一样的，那么是怎么通过一个统一的write和read来找到对应的操作呢？看一下write函数的声明<code>size_t write(int fd, const void *buf, size_t nbytes)</code>,从进程这边传过去的唯一一个可能区分文件类型的就是这个文件描述符fd了，也就是通过这个fd文件系统会找到它到底是哪个文件，再去采取相应的函数调用。当然如果是write操作的话还要涉及到一些对内存加锁的操作。</p>
<h2>另一种管道FIFO</h2>
	<p>如果说管道有什么缺点的话，就是它只能在自家亲戚中使用，不利于社会共同富裕，没有关系的进程就无法通过管道进行勾搭了。于是内核打算采用一种实名制的方式来登记一下管道，这就是FIFO。</p>
	<p>FIFO和pipe用的是同样的数据结构，同样的读写方式，不同的是内核为他们在磁盘注册了一个节点，这样所有进程都能看到这个硬盘上的节点，只要有权限就可以操作了，当然内容还是在内存中。并且这个实体可以用读写模式来打开，也就可以实现全双工了。</p>
	<h2>其他的话</h2>
	<img src="http://lh6.googleusercontent.com/-vRXcYw7V7fg/T69fVsIkNaI/AAAAAAAAAIw/Y3KgmC33VbI/s512/linux.jpg" style="float:left;width:243px;height:208px">
	<p>上面都是一些机制的介绍。其实想写一下读源码的感受的，只是源码的感受过于琐碎，很难理出一个头绪来，而且源码的大框架是上面的机制，但看得时候注意到的更多是细节的实现方式，很多东西是和机制无关的。本以为这段的代码变更应该不会很大，但是看了一下commit记录发现变化还是很多的，很多新加的功能是除了注释找不到相关介绍的，只能自己从代码里推敲。还有一些改进方式是为了弥补以前的缺陷的，看这部分可以提升一些对系统整体的认识。所以鼓励大家在看过原理之后还是要看一下代码，代码中会有很多意外的收获，而这些收获又是很难通过别人讲述获得的。</p>
	<p></p>
</div>
